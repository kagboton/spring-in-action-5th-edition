Spring in action 5th edition 
----------------------------

1. Fondationnal Spring 

@SpringBootApplication is a composite application that combine three other annotations
- @SpringBootConfiguration: designates the class as a configuaration class
- @EnableAutoConfiguration: enables Spring Boot automatic configuaration
- @ComponentScan: enables component scanning. This lets declare other classes
with annotations like @Component, @Controler, @Service, and others, to have Spring automatically
discover them and register them as components in the Spring application context.

==>

@RunWith(SpringRunner.class)
@RunWith is a JUnit annotation, providing a test runnner that guides JUnit in running 
a test.
SpringRunner is the runner that provides for the creation of a Spring application context
that the test run against.
SpringRunner is an alias for SpringJUnit4ClassRunner, and was introduced in Spring 4.3 to 
remove the assocaition with a specific version of JUnit

@SpringBootTest telles JUnit to boostrap the test with  Spring Boot capabilities

@WebMvcTest arranges for the test to run in the context of Spring MVC application. It sets up Spring support for testing Spring MVC.
@WebMvcTest(HomeController.class) : arranges for HomeController to be registered in Spring MVC

==>

Spring Boot DevTools
- automatic application restart when code changes
- automatic browser refresh when browser-resources changes
- automatic disable of template caching
- built un H2 console if H2 database is in use


2. Developing web applications : Spring MVC

run spring boot application : mvn spring-boot:run

Spring MVC is annotation-based used to develop web front end for a Spring application


@Data : Lombok annotation that generates all missing methods of a class
@RequiredArgsConstructor
@Slf4j : Lombok-provided annotation that, at runtime will automatically generates an SL4J Logger in the class
    private static finale org.slf4j.Logger log =
        org.slf4j.LoggerFactory.getLogger(DesignTacoController.class);

Thymeleaf's @{} operator is used to produce a context-relative path to the static artifacts
that they're referencing

Field Validation 
Spring MVC supports validation through the Java Bean Validation API or JSR-303 and the implementation of the Validation API such as Hibernate Validator
Validation API and the Hibernate implementation of the Validation API are automatically added to the project as transcient dependencies of Spring Boot starters

Spring Boot starters :: are the dependency descriptors.
 - Spring Boot starters can help to reduce the number of manually added dependencies just by adding one dependency. 

@WebConfig implements the WebMvcConfigurer interface
WebMvcConfigurer :: interface defines severals methods for configuring Spring MVC. It provides default implementation of all the methods.
We just need to override the methods needed
Example to declare a view controller, we override the addViewControllers() method: 
 @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("home");
    }
registry.addViewController("/) returns a ViewControllerRegistration object on which I can call setViewName() to specific the "home "view that the request for "/" should be forward to. 

Template options supported but Spring Boot EnableAutoConfiguration
- Freemarker: spring-boot-starter-freemarker
- Groovy Templates: spring-boot-starter-groovy-templates
- JavaServer Pages (JSP): none (provided by Tomcat or Jetty)
- Mustache: spring-boot-starter-mustache
- Thymeleaf: spring-boot-starter-thymleaf 

Spring detects autom the template used so we can start writting templates in /src/main/resources/templates
If we choose JSP, we should look at somewhere under /WEB-INF. JSP is only an option if we are building our application as a WAR field 
and deploying it in a traditiona servlet container. So if we are building our application as a JAR file, there's no way to satisfy that requirement.

Caching Templates: properties to enable/disable template caching. By default all are true. If we are using Spring Boot's DevTools, they will be disabled
- Freemaker: spring.freemarker.cache
- Groovy Templates: spring.groovy.templatee.cache
- Mustache: spring.mustache.cache
- Thymeleaf: spring.thymeleaf.cache 


3. Working with data

When it come to working relational data, the most common choice are JDBC and th JPA
JDBC: Java Database Connectivity

Spring supports both of these with abstractions. 

3.1. JDBC

JDBC support is rooted in the JdbcTemplate class. It makes queries easier than normal JDBC use.
We need to add JDBC to the project classpath to use JdbcTemplate : spring-boot-starter-jdbc. We can use H2 for the database during development. 

@Repository annotation is added to the class that will handle queries. 
This annotation is one of a handful of stereotype annotations that Spring defines, including @Controller and @Component

- query(): jdbc method that returns a collection of an object. It accepts the SQL for the query as well as an implementationof Spring's RowMapper for mapping each row in the result set of an object
- queryForObject(): works like query() but returns only a single object
- update(): inserting a row. writes or updates in the database. require a String containing the query

Database schema definition: if there's a file named schema.sql in the root of the application's classpath, then the SQL in the fie will be excecuted against the database
Spring Boot will also execute a file named data.sql from the root of the classpath when the application starts 
The files should be placed in the src/main/resources

update() method can accepts a PrepareStatementCreator and a KeyHolder
- PrepareStatementCreator: example
    PreparedStatementCreator psc =
                    new PreparedStatementCreatorFactory(
                            "insert into Taco (name, createAt) values (?, ?)", Types.VARCHAR, Types.TIMESTAMP
                    ).newPreparedStatementCreator(
                            Arrays.asList(
                                    taco.getName(),
                                    new Timestamp(taco.getCreateAt().getTime())
                            )
                    );
- KeyHolder: provides a generated ID


- @SessionAttributes("order") : The class-lvel @SessionAttributes annotation specifies any model objects like the order attribute that should be kept 
in session and available across multiple requests

- @ModelAttribute(name="taco"): ensure that an (Taco) object will be created in the model

- SimpleJdbcInsert: has a couple of usefu methods for executing the insert : execute() amd executeAndReturnKey(). Both methods accept a Map<Spring, Object>, where
the map keys correspond to the column names in the table the data is inserted into

    @Autowired
        public JdbcOrderRepository(JdbcTemplate jdbc) {

            this.orderInserter = new SimpleJdbcInsert(jdbc)
                    .withTableName("Taco_Order")
                    .usingGeneratedKeyColumns("id");

            this.orderTacoInserter = new SimpleJdbcInsert(jdbc)
                    .withTableName("Taco_Order_Tacos");

            this.objectMapper = new ObjectMapper();
        }

- ObjectMapper or Jackson ObjectMapper: java class to serialize Java objects into JSON and deserialize JSON string into Java objects.

- @SuppressWarnings("unchecked"): This annotation allows us to say which kinds of warnings to ignore. To disable compilation warnings
  While warning types can vary by compiler vendor, the two most common are deprecation and unchecked.
      - deprecation: to suppress warnings relative to deprecated method or type
      - unchecked: to suppress warnings relative to unchecked operations. Tells the compiler to ignore when we're using raw types

- org.springframework.web.bind.support.SessionStatus: Simple interface that can be injected into handler methods, allowing them to signal that their session processing is complete. 
- @SessionAttributes: Annotation that indicates the session attributes that a specific handler uses.



3.2. JPA

A few of the most popular Spring Data projects include these:
- Spring Data JPA - JPA persistence against a relational database
- Spring Data MongoDB
- Spring Data Neo4J
- Spring Data Redis
- Spring Data Cassandra


Spring Data JPA starter dependency

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

This starter dependency brings Spring Data JPA with the Hibernate as the JPA dependency. EclipsLink is another implementation of JPA library.

JPA requires that the entities have a no arguments constructor. We can use @NoArgsConstructor from Lombok. As we dont have to use it, it should be private.
We should then set access attribute to AccessLevel.PRIVATE. In the case that we have final properties that must me set, we should set force attribute to true
Lombok @RequiredArgsConstructor ensures that we'll have a required arguments constructor

With JPA repositories version, the repositories need to extends the org.springframework.data.repository.CrudRepository interface.
The first parameter ot CrudRepository interface is the type of the entity to persist, the second parameter is the type of the entity ID.
EX: public TacoRepository extends CrudRepository<Taco, Long> {}
We dont need any implementation. Spring Data JPA automatically generates an implementation on the fly when the application starts.

However we can customise the JPA repositories

Repository methods are composed of a verb, an optional subject, the word By, and a predicate. 
- findByDeliveryZip (Spring deliveryZip): find(verb)-(no subject)By-DeliveryZip(predicate)
- readOrderByDeliveryZipAndPlacedAtBetween(String deliveryZip, Date startDate, Data endDate): read == find == get

Spring Data method signature include a lot of operators. 

We can also use @Query to perform any query we want. 
Ex: 
@Query("Order o where o.deliveryCity='Seattle'")
List<Order> readOrderDeliveredInSeattle()

We can place OrderBy at the end of the method name to sort the results by a specified column: findByDeliveryCityOrderByDeliveryTO(String city)

4. Spring Security